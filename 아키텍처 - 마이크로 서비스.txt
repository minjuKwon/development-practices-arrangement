1. 배경
- Netflix는 빠르게 성장하는 동영상 스트리밍 서비스에 대한 수요를 따라가기 위해 IT 인프라에 변화
 - 프라이빗 데이터 센터에서 퍼블릭 클라우드로 마이그레이션
 - 모놀리식 아키텍처를 마이크로서비스 아키텍처로 대체
- Netflix는 모놀리스에서 클라우드 기반 마이크로서비스 아키텍처로 성공적으로 마이그레이션한 최초의 유명 기업 중 하나로 초기 선구자
 - 플랫폼의 개별 부분을 관리하고 지원하는 1,000개 이상의 마이크로서비스를 소유
 - 엔지니어는 코드를 때로는 매일 수천 번에 달할 정도로 자주 배포



2. 개념
- 소프트웨어가 잘 정의된 경량화 API를 통해 통신하는 소규모의 독립적인 서비스로 구성하는 아키텍처 및 조직적 접근 방식
 - 서비스란 독립적인 소프트웨어 기능 단위 또는 기능 모음
 - 독립적인 소규모 팀에서 보유
- 주요 비즈니스 로직(도메인) 및 데이터베이스 소유
 - 복잡성을 줄여주지는 않지만, 작업이 서로 독립적으로 작동
 - 더 작은 프로세스로 분리하여 복잡성을 관리하기 쉽도록 만듦
 - 업데이트, 테스트, 배포 및 확장은 각 서비스 내에서 이루어짐
- 점진적으로 마이크로서비스 적용 필요
 - 더 많은 마이크로서비스를 사용할수록 유연성은 높아지지만 그만큼 고충도 늘어남 
 - 점진적으로 적용하면 수행 영향도를 더 잘 판단하고 필요한 경우 중지 가능



3. 특징
1)자율성
- 각 구성 서비스는 다른 서비스의 기능에 영향을 주지 않으면서 개발, 배포, 운영하고 확장 가능 
- 개별 구성 요소 간의 통신은 API를 통해 이루어짐.
  - API는 마이크로서비스 내의 여러 서비스가 정보를 공유하고 하나로 작동할 수 있게 하는 중요한 역할
 - 서비스의 코드 또는 구현을 다른 서비스와 공유 불필요

2)전문성
- 각 서비스는 일련의 기능을 위해 설계되며 특정 문제를 해결하는 데 중점
- 서비스에 더 많은 코드를 추가 제공하여 서비스가 복잡해지면 더 작은 서비스로 분할 가능

3)클라우드 네이티브 접근 방식
- 하나의 애플리케이션 내에 있는 각 핵심 기능이 독립적으로 존재할 수 있도록 소프트웨어를 구축
- 개발 팀과 운영 팀이 서로 방해하지 않으면서 협력 가능
 - 동일 애플리케이션 개발에 더 많은 개발자들이 동시 참여할 수 있으므로 개발에 소요되는 시간을 단축	

4)비즈니스 도메인 중심의 모델링
- 도메인 주도 설계를 통해 소프트웨어의 동작을 더 잘 표현하는 코드로 구성 가능. 
 - 비즈니스 도메인을 중심으로 서비스 경계를 정의하여 새로운 기능을 더 쉽게 출시하고 사용자에게 제공
- 최소한의 변경으로 비용 축소 
 - 둘 이상의 마이크로서비스를 변경이 필요한 기능을 출시하려면 많은 비용 소요
 - 각 서비스의 작업 조율, 신규 버전 배포 순서 등에 주의 필요
 - 단일 서비스에서의 변경 보다 많은 작업 필요, 서비스 간 변경을 적게 수행할 수 있는 방법을 선호
- 비즈니스 기능을 최대한 효율적으로 변경하도록 아키텍처를 배치
 - 기능 변경은 프레젠테이션, 애플리케이션, 데이터 계층 등 여러 계층의 변경 필요
 - 각 계층에서 세부적 계층으로 분할 필요 가능성 존재
 - 비즈니스 단위로 나누면 각 기능을 최대한 효율적으로 변경하도록 아키텍처를 배치 가능
 - 기술적 기능의 높은 응집력보다 비즈니스 기능의 높은 응집력을 더 우선시

5)자기 상태 소유
- 다른 마이크로서비스가 소유한 데이터에 액세스하려면 해당 서비스에 데이터 요청 필요
- 마이크로서비스에 어떤 데이터를 공유하고 감출지 결정하는 능력을 제공
 - 자유롭게 변경할 수 있는 기능(내부구현)과 거의 변경하지 않는 기능(소비자가 사용하는 외부 계약)으로 분리
- 독립적 배포성을 위해 마이크로서비스에 대한 하위 호환성을 최소화
 - 호환성을 위해 변경이 필요해지기 때문 
 - 내부 구현 상세와 외부 계약을 명확하게 구분하면 하위 호환성 최소화 가능 
 - 데이터베이스 공유 최소화를 통해 독립성 유지도 가능
- 마이크로서비스에서 내부 상태를 감추는 것은 객체 지향 프로그래밍의 캡슐화와 유사
 - 서비스를 비즈니스 기능 단위로 나눔
 - 각 기능에 대한 사용자 인터페이스, 비즈니스 로직, 데이터 캡슐화 가능  
 - 캡슐화를 통해 비즈니스 기능에 대한 높은 응집력과 낮은 결합도 가능



4. 장점
1)민첩성
- 애자일 작업 방식을 유도
 - 배포가 잦은 소규모 팀에서 애자일 작업 방식을 유도
 - 독립적 소규모 팀 조직을 육성하는 역할을 가짐
- 개발 주기 시간이 단축
 - 팀은 충분한 이해를 바탕으로 하는 소규모 컨텍스트 내에서 활동
 - 독립적이면서 신속하게 업무를 수행 가능
 - 조직의 집계 처리량 측면에서도 큰 이점

2)유연한 확장성
- 독립적 확장
 - 각 서비스가 지원하는 애플리케이션 기능의 수요를 충족하도록 해당 서비스만 확대 가능
 - 팀에 필요한 인프라의 규모 조절, 기능 비용 정확히 측정, 서비스의 수요가 급증하는 경우에도 가용성 유지 가능
- 큰 규모 지원
 - 마이크로서비스는 stateless 구조이므로 요청 간 상태를 저장하지 않음
 - 동일한 서비스를 여러 인스턴스로 복제하여 수평 확장 가능
 - 부하가 증가하면 인스턴스를 클러스터에 신속하게 배포해 부담 완화
 - multitenant 구조로 인해 한 인스턴스가 여러 사용자 요청 처리 가능
 - 시스템 전체가 더 큰 규모의 트래픽과 사용자 수용 가능

3)기술적 자유
- 작업별로 가장 적합한 도구를 선택
 - 모든 규모에 부합하는 접근 방식을 추구하지 않음
 - 팀은 특정한 문제를 해결하는 데 가장 적합한 기술과 언어를 자유롭게 선택 가능 

4)재사용 가능한 코드
- 기능을 여러 용도로 재사용
 - 특정 기능을 위해 구축된 서비스를 다른 기능의 빌딩 블록으로 사용

5)복원성
- 실패에 대한 애플리케이션의 저항성 증가
 -  서비스가 독립적이므로 전체 애플리케이션에 영향을 주지 않음
 - 저렴한 실패 비용으로 쉽게 코드를 업데이트하고 새로운 기능의 출시 시간을 앞당김
- 빠른 배포
 - CI/CD 통해 새로운 아이디어를 쉽게 시험하고 문제 발생 시 간단히 롤백 가능 



5. 단점
1)무분별한 개발 확산
- 복잡성 증가
 - 여러 팀이 많은 서비스를 만들기에 오히려 진행 속도가 느려지고 운영 성능이 저하
- 표준화 부족 
 - 공통 플랫폼이 없어 여러 언어, 로깅 표준 및 모니터링 사용
- 기하급수적인 인프라 비용
 - 각각의 서비스에 대한 호스팅 인프라, 테스트 및 배포 도구, 모니터링 도구 등 자체적인 비용이 발생

2) 의사소통의 어려움
- 조직 오버헤드 추가
 - 업데이트 및 인터페이스를 조정하기 위해 또 다른 커뮤니케이션과 공동 작업 필요
- 명확한 소유권 부족 
 - 여러 서비스에 따라 실행하는 팀의 수도 증가
 - 시간이 지나면서 팀에서 어떤 서비스를 활용할 수 있는지, 지원을 위해 누구에게 문의해야 하는지 파악하기 어려움

3)데이터 관리 문제
- 여러 서비스 간의 데이터 일관성 유지 및 거래가 복잡
 - 데이터 무결성을 지원하기 위한 신중한 데이터 관리 및 조정이 필요

4)디버깅 문제 
- 자체적인 로그 집합으로 디버깅의 어려움
 - 여러 시스템에서 하나의 비즈니스 프로세스가 실행될 수 있으므로 디버깅이 더욱 복잡
 - 로컬 통합 개발 환경(IDE)을 통한 원격 디버깅 고려 필요



6. 모놀리식 아키텍처
1)개념 
- 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행
- 하나의 코드 베이스를 갖춘 대규모의 단일 컴퓨팅 네트워크
- 애플리케이션의 한 프로세스에 대한 수요가 급증하면 해당 아키텍처 전체를 확장
 - 기능 추가나 개선이 더 복잡 
- 종속 관계를 가짐 
 - 긴밀하게 결합된 많은 프로세스로 인해 단일 프로세스의 실패로 인한 영향이 증가
 - 애플리케이션 가용성에 대한 위험을 가중

2)장점
- 손쉬운 배포 
 - 실행 파일 또는 디렉토리가 하나여서 배포가 쉬움
- 단순한 개발
  - 하나의 코드 베이스로 애플리케이션을 구축하여 개발이 더 쉬움
- 성능 
 - 중앙 집중식 코드 베이스 및 리포지토리에서는 대부분 하나의 API
 - 마이크로서비스에서 여러 API가 수행하는 것과 동일한 기능을 수행
- 테스트 간소화 
 - 하나의 중앙 집중식 장치이므로 분산된 애플리케이션보다 엔드투엔드 테스트를 더 빠르게 수행
- 간편한 디버깅 
 - 모든 코드가 한 곳에 있으므로 요청을 따라가며 문제 찾기 가능

3)단점
- 대규모에 불리 
 - 대규모 모놀리식 애플리케이션에서는 개발이 더욱 복잡해지고 속도가 느려짐
- 낮은 확장성
  - 개별 컴포넌트 확장 불가
- 불안정성
 - 모듈에 오류가 있으면 애플리케이션 전체의 가용성에 영향
- 기술 채택의 장벽 
 - 프레임워크 또는 언어를 변경하면 애플리케이션 전체에 영향
 - 변경 시 비용과 시간이 많이 소요
- 유연성 부족 
 - 모놀리스의 경우 모놀리스에서 이미 사용한 기술로 제한
 - 약간만 변경하는 경우에도 전체 모놀리스를 재배포



7. 서비스 지향 아키텍처(SOA) vs 마이크로 서비스 아키텍처
마이크로서비스 아키텍처는 서비스 지향 아키텍처(SOA)가 진화한 형태
크고 복잡한 애플리케이션을 작업하기 쉬운 작은 구성 요소들로 세분화한다는 점에서 유사
SOA가 전사적인 아키텍처 접근 방식, 마이크로서비스는 애플리케이션 개발 팀의 구현 전략. 범위 차이



8. 필요 기술
1)컨테이너
- 서비스를 패키지로 나누고 배포 컨테이너에 넣어 더 나은 제어와 솔루션의 쉬운 확장성을 가짐
 - 개별 컨테이너는 자체 운영 체제의 오버헤드가 없음
 - 기존 가상 머신보다 작고 가벼우며 더 빠르게 스핀업 및 스핀다운

2)API 게이트웨이
- 유용한 중개 계층
 - API를 통해 클라이언트와 서비스가 서로 직접 통신 
- 클라이언트를 위한 역방향 프록시 역할
 - 요청을 라우팅하고 여러 서비스에 걸쳐 요청을 분산하며 추가 보안 및 인증을 제공

3)클라우딩
- 실질적인 비용 최적화
 - 독립적으로 확장 가능한 소규모 구성 요소와 온디맨드 종량제 인프라를 결합
- 각 개별 구성 요소가 특정 업무에 가장 적합한 스택 채택 가능
 - 스택이 급증할 때, 직접 관리할 경우 심각한 복잡성과 오버헤드가 발생
 - 클라우드 서비스로서 지원 스택을 소비하면 관리 문제를 최소화
 
4)서버리스
- 서버리스 컴퓨팅
 - 개발자는 애플리케이션을 빌드, 실행하고 클라우드 공급업체는 서버 인프라의 프로비저닝, 유지 관리, 확장을 담당하는 클라우드 네이티브 개발 모델
 - 개발자는 배포를 위한 코드 컨테이너의 패키징에만 집중 
- 애플리케이션이 기반 인프라에서 추상화되므로 조직이 더 빠르게 혁신
- 서버리스의 실행 단위는 작은 서비스가 아니라 함수
 - 코드 몇 줄에 불과
 - 일반적으로 기능은 마이크로서비스보다 더 작은 편 

5)스토리지 및 데이터베이스
- 확장 가능하고 내구성이 뛰어나며 안전한 데이터 스토리지

6)네트워킹
- 처리량이 높고 지연 시간이 적은 네트워킹 서비스
 - 더 많은 네트워크 연결이 필요하므로 지연 시간 및 연결 문제 증가

7)메시징 및 이벤트 스트리밍
- 프로세스 간 통신을 게시 및 조정
 - 서비스는 메시지 브로커를 통해 메시지를 교환하여 분리를 기대하고 확장성을 높임
 - 많은 양의 데이터나 이벤트를 처리해야 할 때 가장 효과적
- 이벤트는 마이크로서비스 서비스 내에서 발생하는 모든 것으로 정의
 - 이벤트는 이벤트 스트림으로 형성되고, 이벤트 스트림은 시스템의 행동 변화를 반영
 - 이벤트를 모니터링하면 조직은 데이터와 사용자 행동에 관한 유용한 결론에 도달
 - 이벤트 스트림 프로세싱을 적용하면 즉각적인 조치 가능. 실시간으로 운영 워크로드에 직접 사용 
 - 오늘날 기업들은 이벤트 스트리밍을 사기 분석에서 머신 유지 관리까지 모든 것에 적용
- 마이크로서비스를 이벤트 기반 아키텍처와 결합
 - 대량의 이벤트 또는 정보를 실시간으로 사용하고 처리할 수 있는 확장성과 내결함성이 뛰어난 분산형 시스템을 구축
 - 어쩔 수 없이 상태가 존재할 때 최신 상태 유지를 위해 API보다는 메시징 또는 이벤트 스트리밍과 결합
 - 서비스가 상태 변경 사항을 브로드캐스트하고 다른 이해관계자가 이러한 변경 사항을 수신하여 그에 따라 조정.
 - 이 작업은 범용 메시지 브로커가 해당.

8)로깅 및 모니터링
- 로깅
 - 포괄적인 로그는 개발자가 서비스 전반의 거래를 디버깅하고 추적하는 데 도움이 되어 시스템 상태 및 신뢰성을 지원.
 - 분산 시스템에서는 모든 내용을 한곳에 모을 수 있는 중앙집중식 로그가 필요
 - 확장 시에 로그 관리에 어려움 존재. 
 - 문제 해결 및 최적화를 위해 복잡한 아키텍처에서 추적이 필요해짐
- 모니터링
 - 실시간 서비스 성능 추적, 병목 현상 찾기 및 문제 감지를 단순화
 - 서비스 성능 및 리소스 사용률을 모니터링
 - 문제의 근원을 정확히 집어내려면 모니터링을 통해 시스템을 중앙에서 파악하는 것이 중요

9)DevOps
- 커밋에서 실행에 이르기까지 코드 수명 주기를 관리
- DevOps같은 애자일 개발 방식과 결합
 - 개발 주기를 더욱 가속화
 - 팀이 사용자 요구 사항에 빠르게 적응할 수 있도록 하는 지속적 배포가 관행
 - 작업을 자동화, 마이크로서비스 아키텍처의 안정성 및 확장성을 유지
 - 더 빠르고 안정적인 릴리스를 보장하여 애질리티 및 신뢰성을 높임



9. 참고 패턴
1)Backend-for-frontend(BFF) 패턴
- 사용자 경험과 경험이 호출하는 리소스 사이에 계층을 삽입
 - 예를 들어 데스크톱에서 사용하는 앱은 모바일 디바이스와 화면 크기, 디스플레이 및 성능 제한이 다름
- BFF 패턴을 사용하면 개발자는 모든 인터페이스에서 작동
 - 프론트엔드 성능에 부정적인 영향을 미칠 수 있는 일반적인 백엔드를 지원하는 대신 해당 인터페이스에 가장 적합한 옵션을 사용
 - 사용자 인터페이스당 하나의 백엔드 유형을 생성하고 지원 가능

2)엔티티 및 집계 패턴
- 엔티티는 해당 ID로 구별되는 개체
 - 예를 들어, 전자 상거래 사이트에서 제품 개체는 제품 이름, 유형 및 가격으로 구별 
- 집계는 하나의 단위로 취급되어야 하는 관련 엔티티의 모음 
 - 전자 상거래 사이트의 경우 주문은 구매자가 주문한 제품(엔티티)의 모음(집합)
 - 이러한 패턴은 의미 있는 방식으로 데이터를 분류하는 데 사용

3)서비스 검색 패턴
- 애플리케이션과 서비스가 서로를 찾는 데 도움
 - 마이크로서비스 아키텍처에서 서비스 인스턴스는 크기 조정, 업그레이드, 서비스 실패, 심지어 서비스 종료로 인해 동적으로 변경
 - 이러한 일시적인 상황에 대처할 수 있는 검색 메커니즘을 제공
- 로드 밸런싱은 상태 확인 및 서비스 실패를 트리거로 사용
 - 트래픽을 재조정하는 서비스 검색 패턴을 사용

4)어댑터 마이크로서비스 패턴
- 호환되지 않는 클래스 또는 객체 간의 관계를 변환
- 타사 API에 의존하는 애플리케이션은 애플리케이션과 API가 통신할 수 있도록 어댑터 패턴을 사용

5)스트랭글러 애플리케이션 패턴
- 모놀리식에서 마이크로으로 리팩토에 사용
- 포도나무(마이크로 서비스)가 천천히 시간이 지남에 따라 나무(모놀리식 애플리케이션)를 추월하여 목을 조르는 모습을 비유



10. 고려요소
1)프로젝트 복잡성
- 마이크로서비스 아키텍처는 여러 서비스로 나누기에 광범위하고 복잡한 프로젝트에 도움 
- 단순한 프로젝트에는 마이크로서비스 아키텍처의 오버헤드가 부적합

2)확장성 요구 사항
- 확장 가능하고 유연한 컴포넌트가 필요한 애플리케이션에 적합

3)조직적 준비
- 개발 방법론, 커뮤니케이션 구조 및 운영 프로세스 조정이 필요
 - 조직에서 마이크로 아키텍처으로 변경하는 것에 대비하고 있는지 확인 필요
 - 전문 기술이 필요하므로 개발 팀 내에서 기술 전문성 평가가 필수
- 모놀리스의 고통과 복잡성이 느낄 때 리팩토링 진행
 - 모놀리스 단점을 느끼기 전까지는 리팩토링 불필요

5)크기
- 크기의 개념은 상황에 크게 좌우 
 - 얼마나 많은 마이크로서비스를 처리할 수 있는가? 
 - 마이크로서비스 경계를 최대한 활용하려면 어떻게 경계를 정의해야 하는가? 
- 마이크로를 너무 과도하게 사용하면 아키텍처의 전반적인 이점을 능가하는 오버헤드와 복잡성에 쉽게 직면
- 마이크로서비스가 해결할 수 있는 특성을 마주할 때 변경
 - 배포하기가 어렵고 느려짐
 - 공통 데이터 모델이 지나치게 복잡
 - 서비스의 각 부분마다 부하/규모 요구 사항이 달라짐 등

6)DevOps 또는 클라우드 서비스 사용
- 마이크로서비스 구축은 분산 시스템 구축을 의미
- 분산 시스템은 어렵기에 다음 상황에 유의
 - 적절한 배포 및 모니터링 자동화 없이 마이크로서비스를 수행
 - 현재 무분별하게 확장되는 이기종 인프라를 지원하기 위한 관리형 클라우드 서비스를 제공

7)마이크로서비스를 SOA로 전환하지 않기
- 다른 애플리케이션에서 사용할 수 있는 재사용 가능한 개별 구성 요소 구축에 유의점 존재
- 마이크로서비스는 리팩토링으로 관리하기 쉬운 반면, SOA는 전사적으로 IT 서비스가 작동하는 방식을 변경하는 데 중점
- SOA 프로젝트로 전환되는 마이크로서비스 프로젝트는 그 자체의 부담을 견디지 못할 가능성이 높음



출처
https://aws.amazon.com/ko/microservices/
https://www.redhat.com/ko/topics/microservices/what-are-microservices
https://www.atlassian.com/ko/microservices/microservices-architecture/microservices-vs-monolith
https://www.atlassian.com/ko/microservices/cloud-computing/advantages-of-microservices
https://www.hanbit.co.kr/channel/view.html?cmscode=CMS7041033157
https://www.ibm.com/kr-ko/topics/microservices
https://payproglobal.com/ko/%EB%8B%B5%EB%B3%80/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80/