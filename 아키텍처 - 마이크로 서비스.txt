1. 배경
2009년 Netflix는 성장통을 겪었습니다. 빠르게 성장하는 동영상 스트리밍 서비스에 대한 수요를 인프라가 따라갈 수 없었습니다. Netflix는 IT 인프라를 프라이빗 데이터 센터에서 퍼블릭 클라우드로 마이그레이션하고 모놀리식 아키텍처를 마이크로서비스 아키텍처로 대체하기로 결정Netflix는 모놀리스에서 클라우드 기반 마이크로서비스 아키텍처로 성공적으로 마이그레이션한 최초의 유명 기업 중 하나로 초기 선구자. 2015년에 JAX 특별 심사위원상을 수상한 것도 부분적으로는 DevOps를 내부에 두는 이 새로운 인프라 덕분이었습니다. 오늘날 Netflix는 플랫폼의 개별 부분을 관리하고 지원하는 1,000개 이상의 마이크로서비스를 가지고 있고 엔지니어는 코드를 때로는 매일 수천 번에 달할 정도로 자주 배포



2. 개념
소프트웨어가 잘 정의된 경량화 API를 통해 통신하는 소규모의 독립적인 서비스로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식입니다. 이러한 서비스는 독립적인 소규모 팀에서 보유.
이러한 서비스에는 특정한 목표를 가진 자체 비즈니스 로직 및 데이터베이스가 있습니다. 업데이트, 테스트, 배포 및 확장은 각 서비스 내에서 이루어집니다. 마이크로서비스는 주요 비즈니스, 도메인별 문제를 별도의 독립적인 코드 베이스로 분리합니다. 마이크로서비스는 복잡성을 줄여주지는 않지만, 작업이 서로 독립적으로 작동하고 전체에 기여하는 더 작은 프로세스로 분리하여 복잡성을 눈으로 볼 수 있고 관리하기 쉽도록 만듭.  다이얼을 높은 쪽으로 돌리고 더 많은 마이크로서비스를 사용할수록 유연성은 높아지지만 그만큼 고충도 늘어나게 되죠. 이러한 이유로 필자는 점진적인 마이크로서비스 채택을 강력히 지지합니다. 다이얼을 조금씩 돌려 소리를 키우듯, 점진적으로 적용하면 수행 영향도를 더 잘 판단하고 필요한 경우 중지할 수도 있으니까요.



3. 모놀리식 아키텍처 vs 마이크로 서비스 아키텍처
모놀리식 아키텍처의 경우 모든 프로세스가 긴밀하게 결합되고 단일 서비스로 실행됩니다. 하나의 코드 베이스를 갖춘 대규모의 단일 컴퓨팅 네트워크. 따라서 애플리케이션의 한 프로세스에 대한 수요가 급증하면 해당 아키텍처 전체를 확장. 기능을 추가하거나 개선하기가 더 복잡. 이로 인해 실험에 제한을 받고 새로운 아이디어를 구현하기가 어려워집니다. 종속 관계를 이루며 긴밀하게 결합된 많은 프로세스로 인해 단일 프로세스의 실패로 인한 영향이 증가함에 따라 모놀리식 아키텍처는 애플리케이션 가용성에 대한 위험을 가중

장점
손쉬운 배포 – 실행 파일 또는 디렉토리가 하나여서 배포가 더 쉽습니다.
개발 – 하나의 코드 베이스로 애플리케이션을 구축하여 개발이 더 쉽습니다.
성능 – 중앙 집중식 코드 베이스 및 리포지토리에서는 대부분 하나의 API만으로 마이크로서비스에서 여러 API가 수행하는 것과 동일한 기능을 수행할 수 있습니다.
테스트 간소화 – 모놀리식 애플리케이션은 하나의 중앙 집중식 장치이므로 분산된 애플리케이션보다 엔드투엔드 테스트를 더 빠르게 수행할 수 있습니다.
간편한 디버깅 – 모든 코드가 한 곳에 있으므로 요청을 따라가서 문제를 찾기가 더 쉽습니다.

단점
느린 개발 속도 – 대규모 모놀리식 애플리케이션에서는 개발이 더욱 복잡해지고 속도가 느려집니다.
확장성 – 개별 컴포넌트를 확장할 수 없습니다.
안정성 – 모듈에 오류가 있으면 애플리케이션 전체의 가용성에 영향을 줄 수 있습니다.
기술 채택의 장벽 – 프레임워크 또는 언어를 변경하면 애플리케이션 전체에 영향을 미치므로 변경 시 비용과 시간이 많이 소요되는 경우가 많습니다.
유연성 부족 – 모놀리스의 경우 모놀리스에서 이미 사용한 기술로 제한됩니다.
배포 – 모놀리식 애플리케이션을 약간만 변경하는 경우에도 전체 모놀리스를 다시 배포해야 합니다.

마이크로서비스 아키텍처의 경우, 애플리케이션의 각 기능이 독립적인 구성 요소로 구축되어 각 애플리케이션 프로세스가 서비스로 실행됩니다. 이러한 서비스는 경량 API를 사용하여 잘 정의된 인터페이스를 통해 통신합니다. 서비스는 비즈니스 기능을 위해 구축되며 서비스마다 한 가지 기능을 수행합니다. 서비스가 독립적으로 실행되기 때문에 애플리케이션 전체를 중단하지 않고 특정 기능에 대한 요구를 충족하도록 각각의 서비스를 업데이트, 빌드, 배포 확장  가능



4. 서비스 지향 아키텍처(SOA) vs 마이크로 서비스 아키텍처
마이크로서비스 아키텍처는 서비스 지향 아키텍처(SOA)가 진화한 형태입니다. 이 두 가지 방식은 크고 복잡한 애플리케이션을 작업하기 쉬운 작은 구성 요소들로 세분화한다는 점에서 유사합니다. 이러한 유사성 때문에 SOA와 마이크로서비스 아키텍처는 혼동하기 쉽습니다. 이 둘의 가장 큰 차이점은 범위에 있습니다. SOA가 전사적인 아키텍처 접근 방식이라면 마이크로서비스는 애플리케이션 개발 팀의 구현 전략



5. 특징
자율성
마이크로서비스 아키텍처의 각 구성 요소 서비스는 다른 서비스의 기능에 영향을 주지 않으면서 개발, 배포, 운영하고 확장할 수 있습니다. 서비스가 해당 코드 또는 구현을 다른 서비스와 공유할 필요는 없습니다. 개별 구성 요소 간의 통신은 잘 정의된 API를 통해 이루어짐.  API는 마이크로서비스 내의 여러 서비스가 정보를 공유하고 하나로 작동할 수 있게 하는 중요한 역할

전문성
각 서비스는 일련의 기능을 위해 설계되며 특정 문제를 해결하는 데 중점을 둡니다. 개발자가 시간이 지남에 따라 서비스에 더 많은 코드를 제공하여 서비스가 복잡해지면 더 작은 서비스로 분할 가능

클라우드 네이티브 접근 방식
하나의 애플리케이션 내에 있는 각 핵심 기능이 독립적으로 존재할 수 있도록 소프트웨어를 구축.개발 팀과 운영 팀이 서로 방해하지 않으면서 협력할 수 있습니다. 따라서 동일한 애플리케이션 개발에 더 많은 개발자들이 동시 참여할 수 있으므로 개발에 소요되는 시간을 단축	

비즈니스 도메인 중심의 모델링
도메인 주도 설계와 같은 기술을 사용하면 소프트웨어의 동작을 더 잘 표현하는 코드를 구성할 수 있습니다. 마이크로서비스 아키텍처에서는 비즈니스 도메인을 중심으로 서비스 경계를 정의하여 새로운 기능을 더 쉽게 출시하고 사용자에게 제공할 수 있습니다. 
둘 이상의 마이크로서비스를 변경해야 하는 제품 기능을 출시하려면 비용이 많이 듭니다. 각 서비스의 작업 조율, 신규 버전 배포 순서 등을 주의 깊게 관리해야 하죠. 이는 단일 서비스(또는 모놀리스) 내부에서 동일한 변경을 수행하는 것보다 훨씬 더 많은 작업이 필요하기 때문에 가능한 한 서비스 간 변경을 적게 수행할 수 있는 방법을 선호
기능 변경은 대개 여러 계층에 걸쳐 나타나 프레젠테이션, 애플리케이션, 데이터 계층의 변경이 필요합니다. 이러한 문제는 아키텍처가 그림의 간단한 예보다 훨씬 더 계층화되면 심각해집니다. 각 계층은 더 많은 계층으로 분할될 때가 많기 때문이죠. 여기서 서비스를 비즈니스 기능 단위로(수직으로) 처음부터 끝까지 한 조각으로 만들면, 비즈니스 기능을 최대한 효율적으로 변경하도록 아키텍처를 배치할 수 있습니다. 우리는 마이크로서비스에서 기술적 기능의 높은 응집력보다 비즈니스 기능의 높은 응집력을 더 우선시하기로 결정

 자기 상태 소유
한 마이크로서비스가 다른 마이크로서비스가 소유한 데이터에 액세스하려면 두 번째 마이크로 서비스에 데이터를 요청해야 합니다. 이는 마이크로서비스에 어떤 데이터를 공유하고 감출지 결정하는 능력을 제공하므로 자유롭게 변경할 수 있는 기능(내부구현)과 거의 변경하지 않는 기능(소비자가 사용하는 외부 계약)을 명확히 분리. 독립적 배포성을 실현하려면 마이크로서비스에 대한 하위 호환성이 없는 변경을 제한해야 합니다. 만약 업스트림 소비자와의 호환성을 깨뜨리면 소비자들에게도 변경을 강요할 것입니다. 마이크로서비스에 대한 내부 구현 상세와 외부 계약을 명확하게 구분하면 하위 호환성이 없는 변경 을 줄이는 데 도움.  마이크로서비스에서 내부 상태를 감추는 것은 객체 지향 프로그래밍object-oriented programming의 캡슐화encapsulation와 유사하죠. 객체 지향object-oriented (OO) 시스템에서 데이터 캡슐화는 정보 은닉의 실제 예시. 정말 필요한 경우가 아니라면 데이터베이스를 공유하지 말고, 공유를 회피하기 위해 할 수 있는 모든 것을 수행하세요. 데이터베이스 공유는 독립적 배포성을 달성하는 데 가장 나쁜 것 중 하나. 필자는 서비스를 적절한 경우에 사용자 인터페이스, 비즈니스 로직, 데이터를 캡슐화하는 비즈니스 기능 단위 조각으로 간주하려고 합니다. 비즈니스와 관련된 기능을 변경하는 노력을 줄이고 싶기 때문입니다. 이러한 방식으로 데이터와 동작을 캡슐화하면 비즈니스 기능에 대한 높은 응집력을 얻을 수 있죠. 또한 서비스의 데이터베이스를 숨김으로써 결합도도 낮출 수 있습니다.



5. 장점
민첩성
마이크로서비스는 해당 서비스를 소유한 독립적인 소규모 팀 조직을 육성하는 역할을 합니다. 배포가 잦은 소규모 팀에서 애자일 작업 방식을 유도. 팀은 충분한 이해를 바탕으로 하는 소규모 컨텍스트 내에서 활동하며 더 독립적이면서 신속하게 업무를 수행할 수 있습니다. 덕분에 개발 주기 시간이 단축됩니다. 그리고 조직의 집계 처리량 측면에서 큰 이점

유연한 확장성
마이크로서비스의 경우 각 서비스가 지원하는 애플리케이션 기능의 수요를 충족하도록 해당 서비스를 독립적으로 확장할 수 있습니다. 따라서 팀은 필요한 인프라의 규모를 적절히 조절하고, 기능의 비용을 정확하게 측정하고, 서비스의 수요가 급증하는 경우에도 가용성을 유지. 마이크로서비스가 부하 용량에 도달하면 해당 서비스의 새 인스턴스를 포함하는 클러스터에 신속하게 배포하여 부담을 완화할 수 있습니다. 이제 여러 인스턴스에 고객이 분산되어 있는 다중 테넌트 및 상태 비저장(stateless)이 되었으며 훨씬 더 큰 크기의 인스턴스를 지원할 수 있습니다.

손쉬운 배포
마이크로서비스는 지속적 통합 및 지속적 전달을 통해 새로운 아이디어를 손쉽게 시험하고 문제가 발생할 경우 간단히 롤백할 수 있게 해 줍니다. 이처럼 저렴한 실패 비용 덕분에 실험을 진행할 수 있어 더 쉽게 코드를 업데이트하고 새로운 기능의 출시 시간을 앞당김

기술적 자유
마이크로서비스 아키텍처는 “모든 규모에 부합하는” 접근 방식을 추구하지 않습니다. 팀은 특정한 문제를 해결하는 데 가장 적합한 기술과 언어를 자유롭게 선택할 수 있습니다. 따라서 마이크로서비스를 구축하는 팀은 작업별로 가장 적합한 도구를 선택

재사용 가능한 코드
소프트웨어를 잘 정의된 소규모 모듈로 분할하면 팀이 기능을 여러 용도로 사용할 수 있게 됩니다. 특정 기능을 위해 구축된 서비스를 다른 기능의 빌딩 블록으로 사용할 수 있는 것입니다. 이를 통해 개발자가 코드를 처음부터 작성하지 않고도 새 기능을 생성할 수 있어 애플리케이션이 자체적으로 부트스트랩 작업을 생성

복원성
서비스가 독립적이므로 실패에 대한 애플리케이션의 저항성이 증가합니다. 모놀리식 아키텍처에서는 단일 구성 요소가 실패하는 경우 전체 애플리케이션이 실패하게 될 수 있습니다. 마이크로서비스에서는 기능을 저하시키고 전체 애플리케이션을 충돌시키지 않는 방식으로 전체 서비스 실패를 처리



6. 단점
무분별한 개발 확산
마이크로서비스의 경우 여러 팀이 더 많은 장소에 더 많은 서비스를 만들기 때문에 모놀리스 아키텍처에 비해 더 복잡해집니다. 무분별한 개발 확산이 적절하게 관리되지 않으면 개발 속도가 느려지고 운영 성능이 저하되는 결과가 나타납니다.

기하급수적인 인프라 비용
각각의 새 마이크로서비스는 테스트 도구, 배포 플레이북, 호스팅 인프라, 모니터링 도구 등에 대한 자체적인 비용이 발생할 수 있습니다.

조직 오버헤드 추가
팀에서는 업데이트 및 인터페이스를 조정하기 위해 또 다른 커뮤니케이션과 공동 작업이 이루어져야 합니다.

디버깅 문제 
각 마이크로서비스는 자체적인 로그 집합을 가지고 있어 디버깅이 더 복잡합니다. 또한 여러 시스템에서 하나의 비즈니스 프로세스가 실행될 수 있으므로 디버깅이 더욱 복잡해집니다. 로컬 통합 개발 환경(IDE)을 통한 원격 디버깅은 필수. 이 방식으로는 수십, 수백 개의 서비스를 관리할 수 없기 때문입니다. 안타깝게도 현재로서는 디버그 방법에 대한 정답이 없습니다'

표준화 부족 
공통 플랫폼이 없어 여러 언어, 로깅 표준 및 모니터링이 사용될 수 있습니다.

명확한 소유권 부족 
더 많은 서비스가 도입됨에 따라 서비스를 실행하는 팀의 수도 늘어납니다. 시간이 지나면서 팀에서 어떤 서비스를 활용할 수 있는지, 그리고 지원을 받으려면 누구에게 문의해야 하는지 파악하기가 어려움

데이터 관리 문제
여러 서비스 간의 데이터 일관성 유지 및 거래가 복잡할 수 있습니다. 마이크로서비스 아키텍처에는 데이터 무결성을 지원하기 위한 신중한 데이터 관리 및 조정이 필요



8. 필요 기술
컨테이너
서비스를 패키지로 나누고 배포 컨테이너에 넣어 더 나은 제어와 솔루션의 쉬운 확장성. 개별 컨테이너는 자체 운영 체제의 오버헤드가 없기 때문에 기존 가상 머신보다 작고 가벼우며 더 빠르게 스핀업 및 스핀다운할 수 있어 마이크로서비스 아키텍처에서 볼 수 있는 더 작고 가벼운 서비스와 완벽하게 어울립니다.

API 게이트웨이
마이크로서비스는 특히 처음 상태를 설정할 때 API를 통해 통신하는 경우가 많습니다. 클라이언트와 서비스가 서로 직접 통신할 수 있는 것도 사실이지만, 특히 애플리케이션의 서비스 수가 시간이 지남에 따라 증가함에 따라 API Gateway는 유용한 중개 계층이 되는 경우가 많습니다. API Gateway는 요청을 라우팅하고 여러 서비스에 걸쳐 요청을 분산하며 추가 보안 및 인증을 제공하여 클라이언트를 위한 역방향 프록시 역할을 합니다.
API 관리 플랫폼을 포함하여 API Gateway를 구현하는 데 사용할 수 있는 여러 기술이 있지만, 마이크로서비스 아키텍처가 컨테이너와 Kubernetes를 사용하여 구현되는 경우 게이트웨이는 일반적으로 인그레스(Ingress) 또는 최근에는 Istio를 사용하여 구현

클라우딩
마이크로서비스가 반드시 클라우드 컴퓨팅과만 관련이 있는 것은 아니지만, 마이크로서비스가 새로운 애플리케이션의 인기 있는 아키텍처 스타일이고 클라우드가 새로운 애플리케이션의 인기 있는 호스팅 대상이라는 것 외에도 두 서비스가 자주 함께 사용되는 몇 가지 중요한 이유가 있습니다.
마이크로서비스 아키텍처의 주요 이점 중에는 구성 요소를 개별적으로 배포하고 확장하는 것과 관련된 활용도 및 비용 이점이 있습니다. 온프레미스 인프라에서도 이러한 이점을 어느 정도 누릴 수 있지만, 독립적으로 확장 가능한 소규모 구성 요소와 온디맨드 종량제 인프라를 결합하면 실질적인 비용 최적화를 이룰 수 있습니다.
둘째, 더 중요한 마이크로서비스의 또 다른 주요 이점은 각 개별 구성 요소가 특정 업무에 가장 적합한 스택을 채택할 수 있다는 점입니다. 스택이 급증하면 직접 관리할 경우 심각한 복잡성과 오버헤드가 발생할 수 있지만, 클라우드 서비스로서 지원 스택을 소비하면 관리 문제를 크게 최소화할 수 있습니다. 다시 말해, 자체 마이크로서비스 인프라를 구축하는 것이 불가능한 것은 아니지만, 특히 이제 막 시작하는 경우에는 바람직하지 않습니다.

서버리스
서버리스 컴퓨팅은 개발자는 애플리케이션을 빌드, 실행할 수 있고 클라우드 공급업체는 서버 인프라의 프로비저닝, 유지 관리, 확장을 담당하는 클라우드 네이티브 개발 모델입니다. 개발자는 배포를 위해 코드를 컨테이너에 패키징하기만 하면 됩니다. 서버리스의 경우 애플리케이션이 기반 인프라에서 추상화되므로 조직이 더 빠르게 혁신. 서버리스의 경우 실행 단위는 작은 서비스가 아니라 함수로, 코드 몇 줄에 불과한 경우가 많습니다. 서버리스 기능과 마이크로서비스를 구분하는 선은 모호하지만, 일반적으로 기능은 마이크로서비스보다 더 작다고 알려져 있습니다. 서버리스 아키텍처와 서비스형(Funcs-as-a-Service) 플랫폼이 마이크로서비스와 비슷한 점은 둘 다 더 작은 배포 단위를 만들고 수요에 따라 정확하게 확장하는 데 관심

스토리지 및 데이터베이스
확장 가능하고 내구성이 뛰어나며 안전한 데이터 스토리지

네트워킹
처리량이 높고 지연 시간이 적은 네트워킹 서비스. 더 많은 네트워크 연결이 필요하므로 지연 시간 및 연결 문제가 발생할 가능성이 더 커지기 때문

메시징 및 이벤트 스트리밍
프로세스 간 통신을 게시 및 조정. 서비스는 메시지 브로커를 통해 메시지를 교환하여 분리를 기대하고 확장성을 높입니다. 이 패턴은 많은 양의 데이터나 이벤트를 처리해야 할 때 가장 효과적
이벤트는 마이크로서비스 서비스 내에서 발생하는 모든 것으로 정의. 이벤트는 이벤트 스트림으로 형성되고, 이벤트 스트림은 시스템의 행동 변화를 반영합니다. 이벤트를 모니터링하면 조직은 데이터와 사용자 행동에 관한 유용한 결론에 도달할 수 있습니다. 이벤트 스트림 프로세싱을 적용하면 즉각적인 조치를 취할 수 있습니다. 이벤트 스트림 프로세싱은 실시간으로 운영 워크로드에 직접 사용될 수 있습니다. 오늘날 기업들은 이벤트 스트리밍을 사기 분석에서 머신 유지 관리까지 모든 것에 적용
상태 비저장 서비스를 설계하는 것이 가장 좋은 방법일 수 있지만, 그럼에도 불구하고 상태는 존재하며 서비스는 이를 인식해야 합니다. API 호출은 특정 서비스의 상태를 처음에 설정하는 데 효과적인 경우가 많지만, 최신 상태를 유지하는 데는 그다지 효과적이지 않습니다. 서비스를 최신 상태로 유지하기 위해 "아직 멀었나?"라는 식의 지속적인 설문조사 방식은 실용적이지 않습니다.
대신 상태 설정 API 호출을 메시징 또는 이벤트 스트리밍과 결합하여 서비스가 상태 변경 사항을 브로드캐스트하고 다른 이해관계자가 이러한 변경 사항을 수신하여 그에 따라 조정할 수 있도록 해야 합니다. 이 작업은 범용 메시지 브로커가 가장 적합할 수 있지만, Apache Kafka와 같은 이벤트 스트리밍 플랫폼이 적합한 경우도 있습니다. 또한 개발자는 마이크로서비스를 이벤트 기반 아키텍처와 결합하여 대량의 이벤트 또는 정보를 실시간으로 사용하고 처리할 수 있는 확장성이 뛰어나고 내결함성이 뛰어난 분산형 시스템을 구축

로깅 및 모니터링
모니터링은 실시간 서비스 성능 추적, 병목 현상 찾기 및 문제 감지를 단순화합니다. 포괄적인 로그는 개발자가 서비스 전반의 거래를 디버깅하고 추적하는 데 도움이 되어 시스템 상태 및 신뢰성을 지원. 서비스 성능 및 리소스 사용률을 모니터링합니다. 분산 시스템에서는 모든 내용을 한곳에 모을 수 있는 중앙집중식 로그가 필요합니다. 그렇지 않으면 확장 시에 이를 관리하기가 불가능. 문제 해결 및 최적화를 위해 복잡한 아키텍처에서 추적.  문제의 근원을 정확히 집어내려면 모니터링을 통해 시스템을 중앙에서 파악하는 것이 중요

DevOps
커밋에서 실행에 이르기까지 코드 수명 주기를 관리.  애자일 개발 방식(예: DevOps)과 결합할 경우 개발 주기를 더욱 가속화. 팀이 사용자 요구 사항에 빠르게 적응할 수 있도록 하는 지속적 배포 관행의 기반이기 때문에 DevOps 채택과 함께 이루어지는 경우가 많음. DevOps는 작업을 자동화하고 마이크로서비스 아키텍처의 안정성 및 확장성을 유지하면서 더 빠르고 안정적인 릴리스를 보장하여 애질리티 및 신뢰성을 높임



9. 참고 패턴
Backend-for-frontend(BFF) 패턴
이 패턴은 사용자 경험과 경험이 호출하는 리소스 사이에 계층을 삽입합니다. 예를 들어 데스크톱에서 사용하는 앱은 모바일 디바이스와 화면 크기, 디스플레이 및 성능 제한이 다릅니다. BFF 패턴을 사용하면 개발자는 모든 인터페이스에서 작동하지만 프론트엔드 성능에 부정적인 영향을 미칠 수 있는 일반적인 백엔드를 지원하는 대신 해당 인터페이스에 가장 적합한 옵션을 사용하여 사용자 인터페이스당 하나의 백엔드 유형을 생성하고 지원할 수 있습니다.

엔티티 및 집계 패턴
엔티티는 해당 ID로 구별되는 개체입니다. 예를 들어, 전자 상거래 사이트에서 제품 개체는 제품 이름, 유형 및 가격으로 구별될 수 있습니다. 집계는 하나의 단위로 취급되어야 하는 관련 엔티티의 모음입니다. 따라서 전자 상거래 사이트의 경우 주문은 구매자가 주문한 제품(엔티티)의 모음(집합)입니다. 이러한 패턴은 의미 있는 방식으로 데이터를 분류하는 데 사용됩니다.

서비스 검색 패턴
이는 애플리케이션과 서비스가 서로를 찾는 데 도움이 됩니다. 마이크로서비스 아키텍처에서 서비스 인스턴스는 크기 조정, 업그레이드, 서비스 실패, 심지어 서비스 종료로 인해 동적으로 변경됩니다. 이러한 패턴은 이러한 일시적인 상황에 대처할 수 있는 검색 메커니즘을 제공합니다. 로드 밸런싱은 상태 확인 및 서비스 실패를 트리거로 사용하여 트래픽을 재조정하는 서비스 검색 패턴을 사용할 수 있습니다.

어댑터 마이크로서비스 패턴
다른 나라를 여행할 때 사용하는 플러그 어댑터를 생각하는 방식으로 어댑터 패턴을 생각해 보세요. 어댑터 패턴의 목적은 호환되지 않는 클래스 또는 객체 간의 관계를 변환하는 데 있습니다. 타사 API에 의존하는 애플리케이션은 애플리케이션과 API가 통신할 수 있도록 어댑터 패턴을 사용해야 할 수도 있습니다.

스트랭글러 애플리케이션 패턴
이러한 패턴은 모놀리식 애플리케이션을 마이크로서비스 애플리케이션으로 리팩토링하는 것을 관리하는 데 도움이 됩니다. 이 화려한 이름은 포도나무(마이크로 서비스)가 천천히 시간이 지남에 따라 나무(모놀리식 애플리케이션)를 추월하여 목을 조르는 모습을 비유한 것입니다.



10. 고려요소
프로젝트 복잡성
 마이크로서비스 아키텍처는 복잡성을 관리 가능한 서비스로 나눌 수 있으므로 광범위하고 복잡한 프로젝트에 도움이 됩니다. 단순한 프로젝트에는 마이크로서비스 아키텍처의 오버헤드가 적합하지 않을 수도 있습니다.

확장성 요구 사항
마이크로서비스는 확장 가능하고 유연한 컴포넌트가 필요한 애플리케이션에 적합합니다.

팀 전문성
 마이크로서비스 아키텍처에는 전문 기술이 필요하므로 개발 팀 내에서 기술 전문성을 평가하는 것이 필수입니다.

조직적 준비
 마이크로서비스 아키텍처를 구현하려면 개발 방법론, 커뮤니케이션 구조 및 운영 프로세스 조정이 필요합니다. 조직이 이 변화에 대비하고 있는지 확인하는 것이 중요. . 모놀리스의 고통과 복잡성이 서서히 드러나기 시작할 때만 해당 애플리케이션을 더 작은 서비스로 리팩토링할 수 있는 방법을 고려할 가치가 있습니다. 그 고통을 느끼기 전까지는 리팩토링이 필요한 모놀리스가 실제로 존재하지도 않습니다.

크기
결과적으로 크기의 개념은 상황에 크게 좌우됩니다. 마이크로서비스 전환에 막 착수해서10개 이하의 마이크로서비스를 가진 회사와 수년 동안 마이크로서비스를 늘 수행하고 현재는 수백 개의 마이크로서비스를 보유한 회사에 크기에 대한 생각을 물으면 답변이 서로 다른 것처럼. 첫째, 얼마나 많은 마이크로서비스를 처리할 수 있는가? 
둘째, 모든 것이 끔찍하게 결합돼 엉망인 상황을 피하면서 마이크로서비스 경계를 최대한 활용하려면 어떻게 경계를 정의해야 하는가? 를 유의. 마이크로서비스에서 "마이크로"를 너무 과도하게 사용하면 마이크로서비스 아키텍처의 전반적인 이점을 능가하는 오버헤드와 복잡성에 쉽게 직면할 수 있습니다. 더 큰 서비스를 지향하다가 마이크로서비스가 해결할 수 있는 특성, 즉 변경 사항을 배포하기가 어렵고 느려지거나 공통 데이터 모델이 지나치게 복잡해지거나 서비스의 각 부분마다 부하/규모 요구 사항이 달라지는 등의 문제가 발생하기 시작할 때만 서비스를 분리하는 것이 좋습니다.

DevOps 또는 클라우드 서비스 없이는 마이크로서비스 수행하지 않기
마이크로서비스를 구축한다는 것은 분산 시스템을 구축한다는 것을 의미하며, 분산 시스템은 어렵고, 특히 더 어렵게 만드는 선택을 하는 경우 더욱 어렵습니다. 적절한 배포 및 모니터링 자동화 없이 마이크로서비스를 수행하거나, 현재 무분별하게 확장되는 이기종 인프라를 지원하기 위한 관리형 클라우드 서비스를 제공하려고 하면 불필요한 문제가 많이 발생합니다. 번거로움을 덜고 상태를 걱정하는 데 시간을 할애

마이크로서비스를 SOA로 전환하지 않기
마이크로서비스와 SOA는 가장 기본적인 수준에서 다른 애플리케이션에서 사용할 수 있는 재사용 가능한 개별 구성 요소를 구축하는 데 관심이 있다는 점에서 서로 혼동되는 경우가 많습니다. 마이크로서비스와 SOA의 차이점은 마이크로서비스 프로젝트는 일반적으로 애플리케이션을 리팩토링하여 관리하기 쉬운 반면, SOA는 전사적으로 IT 서비스가 작동하는 방식을 변경하는 데 중점을 둔다는 점입니다. SOA 프로젝트로 전환되는 마이크로서비스 프로젝트는 그 자체의 부담을 견디지 못할 가능성이 높습니다.



출처
https://aws.amazon.com/ko/microservices/
https://www.redhat.com/ko/topics/microservices/what-are-microservices
https://www.atlassian.com/ko/microservices/microservices-architecture/microservices-vs-monolith
https://www.atlassian.com/ko/microservices/cloud-computing/advantages-of-microservices
https://www.hanbit.co.kr/channel/view.html?cmscode=CMS7041033157
https://www.ibm.com/kr-ko/topics/microservices
https://payproglobal.com/ko/%EB%8B%B5%EB%B3%80/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%9E%80/